let nachalo;
nachalo='<table border="1"><td id="lev">'
+'<li><i>реально правильное определение максроса</i><br>'
+'&ensp;#define SQUARE(x) ((x)*(x))-<i>Не забываем про скобки</i><br>'
+'&ensp;<a>Также надо внимательно ставить пробелы. Тут они тоже несут смысловую нагрузку</a><br>'
+'<i>Для продолжения макроса при переносе на другую строку ставится знак &#47;</i><br>'
+'#define MAKEWORD(a,b) ((WORD) (((BYTE)(a))&ensp;&#47;<br>'
+'|((WORD)((BYTE)(b)))&lt;&lt;8)))<br>'
+'<i>Далее приведём примеры вложенных макросов:</i><br>'
+'#define PI 3.14159<br>'
+'#define SQUARE(x) ((x)*(x))<br>'
+'#define CIRCLE_AREA(x) (PI*SQUARE(x)) - <i>Мы в шоке</i><br>'
+'<a>аннулирование макроса в любом месте программы производится директивой #undef</a></li><li>'
+'<table border="1"><caption>Предопределённые максросы ANSI</caption><br>'
+'<tr><td width="100">Макрос</td><td>Описание</td></tr>'
+'<tr><td>_DATE_</td><td>Строка представляющая в форме mmm.dd.yyyy дату '
+'создания данного файла</td></tr>'
+'<tr><td>_FILE_</td><td>Имя текущего обрабатываемого файла</td></tr>'
+'<tr><td>_LINE_</td><td>Номер текущей строки обрабатываемого файла</td></tr>'
+'<tr><td>_STDC_</td><td>Опеределён, если установлен режим совместимости с ANSI C</td></tr>'
+'<tr><td>_TIME_</td><td>время начала обработки текущего файла в формате hh:mm:ss</td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'</table><i>И пример использования конечно:</i><br>'
+'#include<iostream><br>'
+'#include <stdio.h><br>'
+'char* Date = __DATE__;<br>'
+'char* Time = __TIME__;<br>'
+'int main(){<br>'
  +'  system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'FILE* file;<br>'
  +'//...<br>'
  +'file=fopen("Ex.cpp","r+t");<br>'
  +'if(file==NULL){<br>'
  	+'std::cout<<"Error fopen() "<<__FILE__<<" файл, "<<__LINE__<<" строка";<br>'
  	+'return 1;}<br>'
    +'return 0;<br>'
+'} <i>//адрес программы выдал</i><br></li><li>'
+'<b>Операциии в директивых препроцессора</b><br>'
+'<i>Есть две операции: 1)подстановка сроки(#), 2)конкатенация</i><br>'
+'<ul><h3>Функции ввода-вывода</h3><br>'
+'<li>считывание блока данных из потока в оперативную память</li>'
+'<li>запись блока данных из оперативной памяти в поток</li>'
+'<li>обновление блока данных в потоке</li>'
+'<li>считвание записи из потока</li>'
+'<li>занесение записи в поток</li>'
+'</ul></li><li>'
+'<i>Когда начинается выполнение программы, открываются следующие потоки:</i><br>'
+'stdin<i>-стандартное устройство ввода;</i><br>'
+'stdout<i>-стандартное устройство вывода</i><br>'
+'stderr<i>-стандартное утсройство сообщений об ошибках;</i><br>'
+'stdprn<i>-стандартное устройство печати;</i><br>'
+'stdaux<i>-стандартное вспомогательное устройство</i><br>'
+'<i>переназнаение ввода с клавиатуры на файл:</i><br>'
+'example &lt; sample.dat<br>'
+'<i>переназначение вывода с дисплея в файл:</i><br>'
+'example > output.dat<br>'
+'<i>Одновременное назначение ввода и вывода</i><br>'
+'example<sample.dat>output.dat<br>'
+'<i>соединение двух потоков:</i><br>'
+'example1 | example2<br></li><li>'
+'<a>Функции ввода и вывода символов</a><br>'
+'#define EOF (-1) <i>- Макрос</i><hr>'
+'#define EOF (-1)<br>'
+'#include <stdlib.h><br>'
+'using namespace std;<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'char ch;<br>'
  +'cout<<"symbol: ";<br>'
  +'ch=getc(stdin);<br>'
  +'printf("Symbol: "%c"\n", ch);<br>'
  +'  return 0;<br>'
+'} <i>//f - "f"</i><br>'
+'</li><ul><a>Функции ввода и вывода строк</a><br>'
+'<li>gets() - char *gets(char *s) <i>cчитывание строки и помещение в переменную(до 5 символов)</i></li>'
+'<li>puts() - int puts(const char *s) <i>выводит тсроку и добавляет символ перевода</i><br>'
+'&ensp;#include<cstdio><br>'
+'int main(){<br>'
	+'&ensp;char* string="strochka";<br>'
	+'&ensp;puts(string);<br>'
+'return 0;<br>'
+'} <i>//strochka</i><br>'
+'</li>'
+'<li>Функция scanf() <i>int scanf(const char *format[, address, ...]);</i></li>'
+'</ul><hr><ul>Объекты строки форматирования<br>'
+'<li type="square">символы - заполнители <i>пробел (&#47;t) и перевод строки (&#47;n)</i></li>'
+'<li type="square">Символы отличные от символов-заполнителей <i> все ASCII кроме %</i></li>'
+'<li type="square">Спецификаторы формата <i>заведуют адресами переменных</i></li>'
+'</ul>'

	+'<table border="1"><caption>Знаки спецификатора формата и зачем нужны</caption>'
+'<tr><td style="color:#ff0">Компонент</td><td style="color:#fff">Обяза-<br>тельный<br>'
+'или нет</td><td style="color:#808">назначение</td></tr>'
+'<tr><td>[*]</td><td>Нет</td><td>Символ подавления присвоения переменной '
+'значения слудующего поля. Текуще поле ввода сканируется, но не сохраняется '
+'в переменной<br>Предполагается, что аргумент, соответствующий спецификатору '
+'формата, содержащему звёздочку, имеет тип, указанный символом типа преобразования '
+'(type_char), который идёт за звёздочкой</td></tr>'
+'<tr><td>[width]</td><td>Нет</td><td>Спецификатор ширины поля. Задаёт максимальное '
+'число считываемых символов. Функция может прочесть меньше символов, если '
+'в потоке ввода встретится символ-заполнитель или непреобразуемый символ</td></tr>'
+'<tr><td>[F|N]</td><td>Нет</td><td>Модификатор величины указателя. Преопределяет '
+'велину по умолчанию аргумента, задающего адрес:<br>N=near pointer<br>'
+'F=far pointer</td></tr>'
+'<tr><td>[h|l|L]</td><td>Нет</td><td>Модификатор типа аргумента. Переолпределяет '
+'тип по умолчанию аргумента, задающего адрес:<br>h=short int<br>'
+'l=long int, если type_char задаёт преобразование в целое l=double; если type_char '
+'преобразование в тип с плавающей точкой. L=long double(верно только для '
+'преобразования в тип с плавающей точкой)</td></tr>'
+'<tr><td>type_char</td><td>Да</td><td>Символ типа(преобразования)(или спецификатор '
+'преобразования)</td></tr>'
+'</table><table border="1"><caption>Символы типа преобразования</caption>'
+'<tr><td>Тип данных</td><td>Ожидаемый вывод</td><td>Тип аргумента</td></tr>'
+'<tr><td colspan="3"><center style="color:#700">Числовой</center/td></tr>'
+'<tr><td>D</td><td>Десятичное целое</td><td>Указатель на целое<br>(int *arg)</td></tr>'
+'<tr><td>D</td><td>Десятичное целое</td><td>Указатель на длинное целое(long *arg)</td></tr>'
+'<tr><td>E,E</td><td>Число с плавающей точкой</td><td>Указатель на float(float *arg)</td></tr>'
+'<tr><td>f</td><td>Число с плавающей точкой</td><td>Указатель на float(float *arg)</td></tr>'
+'<tr><td>G,G</td><td>Число с плавающей точкой</td><td>Указатель на float(float *arg)</td></tr>'
+'<tr><td>o</td><td>Восьмеричное целое</td><td>Указатель на int(int *arg)</td></tr>'
+'<tr><td>O</td><td>Восьмеричное целое</td><td>Указатель на long (long *arg)</td></tr>'
+'<tr><td>i</td><td>Десятичное,восьмеричное или шестнадцатеричное целое</td>'
+'<td>Указатель на int(int *arg)</td></tr>'
+'<tr><td>I</td><td>Десятичное, восмеричное или шестнадцатеричное целое</td>'
+'<td>Указатель на long(long *arg)</td></tr>'
+'<tr><td>u</td><td>Беззнаковое десятичное целое</td><td>Указатель на unsigned int'
+'(unsigned int *arg)</td></tr>'
+'<tr><td>U</td><td>Беззнаковое десятичное целое</td><td>Указатель на unsigned long'
+'(unsigned long *arg)</td></tr>'
+'<tr><td>x</td><td>Шестнащдццатеричное целое</td><td>Указатель на int(int *arg)</td></tr>'
+'<tr><td>X</td><td>Шестнадцатеричное целое</td><td>Указатель на int(int *arg)</td></tr>'
+'<tr><td colspan="3"></td></tr>'
+'<tr><td colspan="3"><center style="color:#505">Символы</center/td></tr>'
+'<tr><td>s</td><td>Символьная строка</td><td>Указатель на символьный массив (char arg[])</td></tr>'
+'<tr><td>c</td><td>Символ</td><td>Указатель на символ(char *arg), если задана '
+'ширина поля для символов С-типа(например %5С). Указатель на массив из '
+'N символов<br>(char arg[N])</td></tr>'
+'<tr><td>%</td><td>%символ</td><td>Никакое преобразование не выполнятеся; '
+'знак % сохраняется</td></tr>'
+'<tr><td colspan="3"><center style="color:#44a">Указатели</center></td></tr>'
+'<tr><td>n</td><td>Указатель на int(int *arg)</td><td>Число успешно прочитанных '
+'символов, вплоть до %n сохраняется в этом ште</td></tr>'
+'<tr><td>p</td><td>Шестнадцатеричная форма<br>YYYY:ZZZZ или ZZZZ</td><td>Указатель '
+'на объект (far* или near*).<br>По умолчанию %p преобразовывает в указатель, '
+'величина которого принята в данной модели памяти</td></tr>'
+'</table>'
+'<li><a>Спецификаторы формата</a><br>'
+'<a>%[abcd]</a> - поиск во входном потоке любого из символов a,b,c,d<br>'
+'<a>%[^abcd]</a> - поиск всех символов, исключая a,b,c,d<br>'
+'<i>int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'char symbol;<br>'
  +'cout<<"symbol: ";<br>'
  +'symbol!="a"||"b"||"c"||"d";<br>'
  +'for(int i=0;i<5;i++){<br>'
	+'  cin>>symbol; <a>//a,b,c,d,f</a><br>'
+'}<br>'
+'cout&lt;&lt;symbol;<br>'
  +'  return 0;<br>'
+'}  <a>// f</a></i><br>'
+'<i>Также: </i><br>%[0-9] - Поиск во входном поле любой десятичной цифры<br>'
+'%[0-9A-Za-z] - Поиск во входном потоке десятичных цифр и букв<br>'
  +'</td><td id="lpcool"></td>'
+'<td id="prav">'
	+'<li><a>sscanf()</a><br>'
+'#include<iostream><br>'
+'#include <stdio.h><br>'
+'using namespace std;<br>'
+'int main(){<br>'
  +'  system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
    +'char szBuf1[]="***This function can parcse string***";<br>'
+'    char szBuf2[]="Integer i=12345,f1=123.456";<br>'
  +'  char s[5][11]; char str1[11],str2[11];<br>'
    +'char c1,c2,c3;int i;float fl;<br>'
+'    sscanf(szBuf1,"%s %s %s %s %s ",s[0],s[1],s[2],s[3],s[4]);<br>'
  +'  sscanf(szBuf2,"%s %c %c %d %s %c %f",str1,&c1,&c2,&i,str2,&c3,&fl);<br>'
    +'printf("sscanf() parse this string: \n"<br>'
	  +'      "%s %s %s %s %s\n ",<br>'
		+'	   s[0],s[1],s[2],s[3],s[4]);<br>'
+'	printf("szBuf2 contains:\n %s %c %c %d %s %c %8.3f ",<br>'
	+'         str1,c1,c2,i,str2,c3,fl);<br>'		   
+'    return 0;<br>'
+'} <i>//возвратила только числа<br>'
+'// Integer i = 12345 ,f1=123.456 ¦    0,000</i><br></li><li>'
+'<ul><a>Строка форматирования в функции printf()</a><br>'
+'Содержит два типа:<br><li type="square">Простые символы, которые копируются '
+'в выходной поток;</li>'
+'<li type="square">Спецификаторы формата, которые применяются к аргументам, '
+'выбираемым из списка аругментов</li></ul>'
+'<a>% [flags] [width] [.prec] [F|N|h|l|L] type_char</a><br>'
+'<table border="1"><caption style="font-size:16px">Компоненты спецификатора формата '
+'и их назначение</caption>'
+'<tr><td width="100px"><i>Компонент</i></td><td width="80px"><i style="margin:0">Обязательный или нет</i></td><td width="200px"><i>Назначение</i></td></tr>'
+'<tr><td>[flags]</td><td>Нет</td><td>Флаговые символы. Управляют выравниванием, '
+'знаком числа, десятичной точкой, конечными нулями, префиксами для восьмеричных '
+'и шестнадцатеричных чисел.</td></tr>'
+'<tr><td>[width]</td><td>нет</td><td>Спецификатор ширины(поля). Указывает '
+'минимальное число выводимых сиволов(дополняются, если это необходимо, '
+'пробелами или нулями)</td></tr>'
+'<tr><td>[prec]</td><td>нет</td><td>Спецификатор точности. Указывает макимальное '
+'число выводимых символов; для целых чисел - минимальное число выводимых цифр.</td></tr>'
+'<tr><td>[F|N|h|l|L]</td><td>нет</td><td>Модификатор размера. Переопределяет '
+'размер входного аргумента по умолчанию.</td></tr>'
+'<tr><td>Type_char</td><td>да</td><td>Символ типа преобразователя</td></tr>'
+'</table><table border="1" bordercolor="#888"><caption>Флаговые символы(флажки) и их назначение</caption>'
+'<tr><td>Флажок</td><td>Назначение</td></tr>'
+'<tr><td>"-"</td><td>Выравнивает результат преобразования влево, дополняя его '
+'справа пробелами. По умолчанию(т.е. когда этот флажок ещё не задан) результат '
+'преобразорвания выравнивается вправо и дпоолняется слева нулями или пробелами.</td></tr>'
+'<tr><td>"+"</td><td>Если результат преобразования имеет знак, этот знак всегда выводится. '
+'Это означает, что для положительных чисел выводится знак плюс (+).</td></tr>'
+'<tr><td style="text-align:center">пробел<br>(" ")</td><td>Если значение отрицательно, вывод начинается с пробела '
+'вместо знака плюс. Отрицательные числа по-прежнему выводятся со знаком минус.</td></tr>'
+'<tr><td>"#"</td><td>Задаёт, что аргумент преобразуется с использованием '
+'альтернативной формы</td></tr>'
+'</table>'
	+'<br><ul><i>Спецификатор ширины поля (ширина вводимого значения)</i><br>'
+'<li type="square">непосредственно с помощью десятичного числа</li>'
+'<li type="disc">косвенно, с помощью символа звёздочки (*)</li>'
+'</ul><table border="1pt">'
+'<tr><td width="60px">Спецификаторы ширины</td><td>Влияние на вывод</td></tr>'
+'<tr><td>N</td><td>По крайней мере n символов выводятся. Если выводимое '
+'значение имеет менее чем n символов, вывод дополняется пробелами(справа, '
+'если указана флажлк минус(-), слева - в противном случае).</td></tr>'
+'<tr><td>On</td><td>Выводится по меньшей мере n символов. Если выводимое значение '
+'меньше, чем n символов, оно дополнятея слева нулями. </td></tr>'
+'<tr><td>*</td><td>Списко аргументов предоставляет спецификатор ширины, который '
+'должен предшествовать реально выводимому аргументу.</td></tr>'
+'</table></li><li>'
+'<a>СпициФикатор точности функции printf()</a><br>'
+'<table><caption>Задаётся двумя способами</caption>'
+'<li type="disc">непосредственно, с помощью десятичного числа</li>'
+'<li type="square">косвенно, с помощью символа звёздочки (*).</li>'
+'</table>'
+'<table border="1"><caption>Значение символа типа преобразования и их назначение'
+'<i>(по умолчанию считается, что ни флажков, ни спецификаторов нет)</i></caption>'
+'<tr><td style="color:#55a";width="50px">Символ типа преобразования</td><td style="color:#246";width="60px">'
+'Ожидаемый ввод</td><td style="color:#321">Формат вывода</td></tr>'
+'<tr><td colspan="3">Числовые значения</td></tr>'
+'<tr><td>d</td><td>целое число</td><td>десятичное целое со знаком</td></tr>'
+'<tr><td>i</td><td>целое число</td><td>десятичное целое со знаком</td></tr>'
+'<tr><td>о</td><td>целое число</td><td>восьмеричное целое без знака</td></tr>'
+'<tr><td>u</td><td>целое число</td><td>десятичное целое без знака</td></tr>'
+'<tr><td>x</td><td>целое число</td><td>шестнадцатеричное целое без знака '
+'(причём для 16-ричных цифр используются символы a,b,c,d,e,f)</td></tr>'
+'<tr><td>X</td><td>Целое число</td><td>шестнадцатеричное целое без знака '
+'(причём дя 16-ричных цифр используются символы A,B,C,D,E,F)</td></tr>'
+'<tr><td>f</td><td>Число с плавающей точкой</td><td>число с плавающшей точкой в виде '
+'<br>[-]dddd.dddd.</td></tr>'
+'<tr><td>e</td><td>Число с плавающей точкой</td><td>Число с плавающей точкой '
+'в виде [-]d.dddd или e[+/-]dddd</td></tr>'
+'<tr><td>g</td><td>число с плавающей точкой</td><td>Число с плавающей точкой в форме e или f '
+'с учётом заданного значения и точности. Конечные нули и десятичные точки выводятся, '
+'если это необходимо</td></tr>'
+'<tr><td>E</td><td>Число с плавающей точкой</td><td>То же, что и е; но для '
+'экспоненты используется символ Е.</td></tr>'
+'<tr><td>G</td><td>Число с плавющей точкой</td><td>То же, что и g; но для экспоненты '
+'используется символ Е, если используется формат е.</td></tr>'
+'<tr><td colspan="3"><center>Символы</center/td></tr>'
+'<tr><td>c</td><td>Символ</td><td>Один символ</td></tr>'
+'<tr><td>s</td><td>Указатель на строку</td><td>Выводит символы до тех пор, пока не встретится '
+'не встретится 0-симивол или не будет достигнута заданная точность</td></tr>'
+'<tr><td>%</td><td>Никакой</td><td>Выводит символ процента (%)</td></tr>'
+'<tr><td colspan="3"><center>Указатели</center></td></tr>'
+'<tr><td>n</td><td>Указатель на int</td><td>Сохраняет по адресу, указанному входным '
+'аргументом, число символов, записаннных до сих пор</td></tr>'
+'<tr><td>p</td><td>Указатель</td><td>Выводит входной аргумент как указатель; формат '
+'зависит от используемой модели памяти. Указатель будет представлен в виде '
+'XXXX:YYYY или YYYY(только смещение)</td></tr></table><table border="1">'
+'<captin>Модификаторы размера и их действие на входную величину</caption>'
+'<tr><td style="width:20">Модификатор размера</td><td>Символ типа преобразования</td><td>Приписываемый входному '
+'аргументу тип</td></tr>'
+'<tr><td>F</td><td>p s</td><td>far-указатель</td></tr>'
+'<tr><td>N</td><td>N</td><td>near-указатель</td></tr>'
+'<tr><td>H</td><td>DiouxX</td><td>short int</td></tr>'
+'<tr><td>L</td><td>diouxX</td><td>long int</td></tr>'
+'<tr><td>L</td><td>eEfgG</td><td>double</td></tr>'
+'<tr><td>L</td><td>eEfgG</td><td>long double</td></tr>'
+'<tr><td>L</td><td>diouxX</td><td>__int64</td></tr>'
+'<tr><td>h</td><td>cC</td><td>Однобайтовый символ</td></tr>'
+'<tr><td>l</td><td>с С</td><td>Широкий символ</td></tr>'
+'<tr><td>h</td><td>s S</td><td>Строка однобайтовых символов</td></tr>'
+'<tr><td>l</td><td>s S</td><td>Строка широких символов</td></tr>'
+'</table></li><li>'
+'<a>Демонстрация возможностей printf():</a><br>'
+'#include<stdio.h><br>'
+'int main()<br>'
+'{<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
    +'char ch=`A`, *string="string";<br>'
	+'int count=-1234;<br>'
	+'double fp=123.4567;<br>'
	+'cout<<"Decimal: "&lt;&lt;count;<br>'
	+'printf("\nDecimal &d as:\n\tHex:"<br>'
	+'"%Xh C-hex: 0x%x Octal: %o\n",count,count,count,count);<br>'
	+'printf("Digits 10 equal:\n\tHex: %i"<br>'
	  +'    " Octal: %i Decimal: %i\n",0x10,010,10);<br>'
	+'printf("Characters:\n%10c%5hc\n",ch,ch);<br>'
	+'printf("String:\n%16s\n%16.4hs\n",string,string);<br>'
	+'printf("Reel nums: \n%f %.2f %e %E\n",fp,fp,fp,fp);<br>'
	+'printf("\nAddress as:\t%p\n",&count);<br>'
	+'printf("\nDisplay to here:\n");<br>'
	+'printf("1234567890123456%n78901234567890\n",&count);<br>'
	+'printf("Number displayed: %d\n\n",count);<br>'
  +'  return 0;<br>'
+'} <i>//Address as:     000000000023fd64<br>'
+'//Display to here:<br>'
+'//123456789012345678901234567890<br>'
+'//Number displayed: 16 (всё не выписывал)</i><br>'
	+'</li></td></table>'
let func;
func='<table><td id="lev"><a>Левая</a><br>'
+'<ol><h4>Функции файлового ввода и вывода</h4>'
+'<li><i>Прототип fopen() следующий:</i><br>'
+'FILE *fopen(const char *filename,<br>'
+'const char *mode);</li>'
+'<table border="1"><caption>Режим открытия файла, который задаётся параметром <a>mode</a></caption>'
+'<tr><td style="color:#ff0" width="40px">Значение</td><td style="color:#00f">Описание</td></tr>'
+'<tr><td>R</td><td>Файл открывается только для чтения.</td></tr>'
+'<tr><td>W</td><td>Файл создаётся для записи. Если файл с таким именем уже '
+'существует, он будет перезаписан.</td></tr>'
+'<tr><td>A</td><td>режим добавления записей(Append); файл открывается для записи в конец '
+'(начиная с EOF) или слхдаётся для хаписи, если он ещё не существует.</td></tr>'
+'<tr><td>r+</td><td>Существующий файл открывается для обновления'
+'(считывание и запись)</td></tr>'
+'<tr><td>w+</td><td>Создаётся новый файл для обновления(считывание и запись). '
+'Если такое имя уже имеется, то он будет перезаписан.</td></tr>'
+'<tr><td>а+</td><td>Файл открывается для добавления(т.е записывания, начиная с EOF); '
+'если нет такого файла, то он создаётся</td></tr>'
+'</table></li>'
+'<li>По завершении работы в потоке указателя, он закрывается функцией fclose()<br>'
+'<a>int fclose(FILE *stream);</a></li>'
+'<li><a>fgetc() </a><i>осуществляет ввод символа из файлового потока</i><br>'
+'int fgetc(FIlE *stream);</li>'
+'<li><a>fputc() </a><i>осуществляет вывод в файловый поток(аналог putc())</i><br>'
+'int fputc(int c, FILE *stream);</li>'
+'<li><a>fgets() </a><i>чтение тсроки из файлового потока в строку (s например)</i><br>'
+'char *fgets(char *s,int n, FIlE *stream);<i>(не путать с fgetc())</i></li>'
+'<li><a> fputs() /a><i>вывод строки в файловый поток</i><br>'
+'int fputs(const char *s,FILE *stream);</li>'
+'<li><a>fscanf() </a><i>форматированный поток из файлового потока</i><br>'
+'int fscanf(FILE *stream, const char *format[, address, ...]);</li></ol>'
+'<li><a>fprintf() </a><i>форматированный вывод в файловый поток</i>'
+'int fprintf(FILE *stream, const char *format[, argument, ...]);</li>'
+'<li><a>feof() </a><i>возвращает ненулевое значение при конце файла</i>'
+'int feof(FILE *stream); <br><i>Пример:</i><br>'
+'&ensp;#include <stdio.h><br>'
+'using namespace std;<br>'
+'int main(){<br>'
+'&ensp;    system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'  FILE *in, *out;<br>'
+'    if((in=fopen("C:\\AUTOEXEC.BAT", "rt"))==NULL){<br>'
    +'	&ensp;fprintf(stderr,"Cannot open input file.\n");<br>'
  +'  	return 1;}<br>'
+'    if((out=fopen("C:\\AUTOEXEC.BAK","wt"))==NULL){<br>'
    +'	&ensp;fprintf(stderr,"Cannot open output file.\n");<br>'
  +'  	return 1;<br>'
+'    } while(!feof(in))<br>'
         +'&ensp;fputc(fgetc(in),out);<br>'
        +' fclose(in);<br>'
      +'   fclose(out);<br>'
    +'     fprintf(stderr,"The file is copied successfully.\n");<br>'
  +'  return 0;<br>'
+'} <i>//врзвратила 1 (конец файла нашла, я так понял)</i><br>'
+'<a>feof() </a><i>это всего лишь макрос</i><br></li>'
+'<li><a>fread() </a><i> читает из потока в указанный ptr буфер'
+'</i><br>size_t<br>fread(void *ptr,size_t size,<br>&ensp;'
+'size_t n, FILE *stream);</li>'
+'<li><a>fwrite() </a><i>запись числа блоков из буфера. Возвращает тоже колличество блоков</i><br>'
+'size_t<br>fwrite(const void *ptr, size_t size,<br>&ensp;'
+'size_t , FILE *stream);<br>'
+'#include<iostream><br>'
+'#include <stdio.h><br>'
+'#include <string.h><br>'
+'#include<stdlib.h><br>'
+'using namespace std;<br>'
+'struct Client{<br>'
	+'int Num;<br>'
	+'char SurName[27];<br>'
+'	char Name[21];<br>'
	+'char SecName[21];};<br>'
+'int main(void){<br>'
  +'  system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
+'   FILE *stream;<br>'
  +' Client AClient,RClient;<br>'
   +'if((stream=fopen("SAMPLE.DAT","wb"))==NULL){<br>'
+'   	printf("Cannot open output file.\n");<br>'
  +' 	return 1;}<br>'
+'   AClient.Num=1;<br>'
  +' strcpy(AClient.SurName,"Voronov");<br>'
+'   strcpy(AClient.Name,"Vova");<br>'
  +' strcpy(AClient.SecName,"Vovanych");<br>'
 +'  fwrite(&AClient,sizeof(AClient),1,stream);<br>'
   +'fclose(stream);<br>'
+'   if((stream=fopen("SAMPLE.DAT","rb"))==NULL){<br>'
  +' printf("Cannot open input file.\n");<br>'
+'   return 2;}<br>'
+'fread(&RClient,sizeof(RClient),1,stream);<br>'
+'fclose(stream);<br>'
+'printf("The structure contains:\n");<br>'
+'printf("Num=%d SurName=%s Name=%s SecName=%s",<br>'
  +'        RClient.Num, RClient.SurName,RClient.Name, RClient.SecName);<br>'
    +'return 0;<br>'
+'} <i>//The structure contains:<br>'
+'//Num=1 SurName=Voronov Name=Vova SecName=Vovanych</i><br></li>'
+'<ol><h4>Функции позиционирования</h4><br>'
+'<i>fseek(),ftell(),rewind() - получение и изменение счётчика</i><br>'
+'<li><a>ftell() - </a><i>возвращает текущее значение счётчика</i><br>'
+'long int ftell(FILE *stream);<i>(при ошибке возвращает 1L)</i> </li>'
+'<li><a>fseek() - </a><i>изменяет позиционировани ефайлов потока stream</i><br>'
+'int fseek(FILE *stream,long offset,<br>&ensp;&ensp;int from);<br>'
+'from принимает следующие значения:<br>'
+'<ul><li>SEEK_SET (=0) - начало файла</li>'
+'<li>SEEK_CUR (=1) - текущая позиция файла</li>'
+'<li>SEEK_END (=2) - конец файла</li></ul>'
+'<li><a>rewind() - </a><i>устанвливает файлдовый указатель позиции в начало потока</i><br>'
+'&ensp;void rewind(FILE *sream);</li>'
+'<a>Работа этих функций: </a><br>'
+'#include<iostream><br>'
+'#include <stdio.h><br>'
+'#include <string.h><br>'
+'#include<stdlib.h><br>'
+'using namespace std;<br>'
+'struct Client{<br>'
+'	int Num;<br>'
	+'char SurName[27];<br>'
+'	char Name[21];<br>'
	+'char SecName[21];};<br>'
+'int main(void){<br>'
+'    system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +' FILE *stream;<br>'
+'   Client AClient,RClient;<br>'
  +' long int pos;<br>'
+'   if((stream=fopen("SAMPLE.DAT","wb"))==NULL){ <i>//вывод файла</i><br>'
    +'  printf("Cannot open output file.\n");<br>'
  +'    return 1;}<br>'
+'   AClient.Num=1;<br>'
  +' strcpy(AClient.SurName,"Petrov");<br>'
+'   strcpy(AClient.Name,"Petr");<br>'
  +' strcpy(AClient.SecName,"Petrovich");<br>'
+'   //запись структуры:<br>'
  +' fwrite(&AClient,sizeof(AClient),1,stream);<br>'
+'   pos=ftell(stream);<br>'
  +' <i>//позиция файла и длина структуры</i><br>'
+'   printf("The file pos=%d structure lenght=%d\n",pos,sizeof(AClient));<br>'
  +'<i> //меняем позицию</i><br>'
  +' rewind(stream);<br>'
+'   <i>//Открываем</i><br>'
   +'if((stream=fopen("SAMPLE.DAT","rb"))==NULL){<br>'
 +'  	printf("Cannot open input file.\n");<br>'
   +'	return 2;}<br>'
 +'  fread(&RClient,sizeof(RClient),1,stream);<br>'
  +' <i>//Закрываем</i><br>'
+'   fclose(stream);<br>'
  +' printf("The Structure contains:\n");<br>'
+'   printf("Num=%d SurName=%s Name=%s SecName=%s",<br>'
    +'     RClient.Num,RClient.SurName, RClient.Name, RClient.SecName);<br>'
  +'  return 0;<br>'
+'} <i>//The file pos=76 structure lenght=76<br>'
+'//The Structure contains:<br>'
+'//Num=1 SurName=Petrov Name=Petr SecName=Petrovich</i><br></ol>'
	+'<ol><h4>Объектно ориентированное программирование</h4><br>'
+'<li><b>Принципы ООП</b><br>'
+'<p><img src="https://i.postimg.cc/MT0XbnCz/abd.png" width="300px" height="250px"><figcaption><i>Абстракция данных</i> - это возможность определять новые типы данных, '
+'с которыми можно работать так-же как и с основными.</figcaption></p><br>'
+'<p><img src="https://i.postimg.cc/gjv50WLS/inc.png" width="300px">'
+'<figcaption><i>Инкапсуляция</i> - механизм, который объединяет данные и код</figcaption></p><br>'
+'<p><img src="https://i.postimg.cc/vHhq2XrV/nasl.png" width="300px" heigth="250px"><figcaption><i>Наследование</i> - процесс при котором один объект приобретает свйоства '
+'другого.</figcaption></p><br>'
	+'<p><img src="https://i.postimg.cc/wx2Y0zbW/image.png" width="300px"><figcaption><i>Полиморфизм</i> - поведение '
+'кода в зависимости от ситуации (по разному)</figcaption></p>'
+'</li></ol>'

+'</td><td id="lpcool">средняя</td>'
+'<td id="prav"><a>Правая</a><br>'
	+'<ul><h4>Классы</h4><br>'
+'<li>class<имя_класса>{<br>'
+'&ensp;//закрытые функции-члены класса<br>'
+'&ensp;public:<br>'
+'//открытые функции-члены класса<br>'
+'} <список_объектов>;</li><li>'
+'<i>Пример объявления класса</i><br>'
+'class AnyClass{<br>&ensp;//закрытый элемент класса<br>'
+'&ensp;int a;<br>&nbsp;public:<br>'
+'&ensp;int get_a();<br>&ensp;void set_a(int num);};<br>'
+'<i>Операция в виде "::" - операция расширения</i><br>'
+'<Тип><имя_класса>::<имя_функции><br>'
+'<div style="text-indent:120px;">(<список_параметров>){</div><br>&ensp;//тело функции<br>}<br>'
+'get_a() и set_a():<br>'
+'void AnyClass::get_a()<br>{return a;<br>}<br>'
+'int AnyClaa::set_a(int num){<br>a=num;}</li><li>'
+'<i>Доступ к элементам баз данных</i><br>'
+'class Coord{<br>'
	+'public:<br>'
		+'int x,y;<br>'
	+'	void SetCoord(int _x,int _y);};<br>'
+'void<br>'
+'Coord::SetCoord(int _x,int _y){<br>'
	+'x=_x;<br>'
	+'y=_y;}<br>'
+'int main(){<br>'
  +'Coord pt;<br>'
+'  Coord *ptPtr=&pt; <i>//указатель на объект</i><br>'
  +'//...<br>'
+'  pt.x=0; <i>//объект</i><br>'
  +'ptPtr->y=0; <i>//указатель->член_класса</i><br>'
+'  ptPtr->SetCoord(10,20);<br>'
  +'//...<br>'
+'    return 0;} //<br>'
+'<hr><i>Кроме того, инструкцию </i>ObjName.FuncName();<br>'
+'<i>компилятор трактует как:</i> (&ObjName)->FuncName();<br>'
+'<i>Для видимости класса может использоваться двойное двоеточие:</i><br>'
+'<имя_класса>::<имя_члена><br>'
+'<ul type="square"><a>Есть и ограничения:</a>'
+'<li>данные-члены не могут определяться с модификаторами auto,extern,register</li>'
+'<li>данным членом класса не может быть объект этого же класса(а указатель может)</li>'
+'<li>функции-члены могут обращаться к элементам класса просто по имени</li>'
+'<li>Класс объявляется до использования его членов(а как иначе...)</li>'
+'<i>Иногда проиходиться прибегать к неполному объялвению класса</i><br>'
+'<i>Неполное объявление класса</i><br>'
+'class PrevDec1;<br>'
+'class AnyClass{<br>'
	+'int x;<br>'
	+'PrevDec1* obPtr;<br>'
   +'public:<br>'
    +'AnyClass(int _x){x= _x;}<br>'
+'}; int main(){<br>'
+'return 0;}<br>'
+'<i>Полное объявление класса</i> <br>'
+'class PrevDec1{<br>'
  +' int a;<br>'
 +'public:<br>'
   +'PrevDec1();<br>'
+'};<br>'
+'<i>Создать объект, полностью не определив класс, нельзя. За исключением: </i><br>'
+'<li type="disc">&ensp;&ensp;Определение класса содержит один или несоклько спецификаторов доступа, '
+'задаваемых с помощью ключевых слов public,protected,private;</li>'
+'<li>&ensp;&ensp;Вместо struct могут применяться class и union</li>'
+'<li>&ensp;&ensp;обычно включает в себя наряду с элементами данных функции-члены</li>'
+'<li>&ensp;&ensp;часто содержит спец-функции. Конструктор или деструктор</li>'
+'<li><a>struct и union:</a><br>'
+'struct Point<a>{</a><br>'
	+'&ensp;private:<br>'
	  +'&ensp;&ensp;int x;<br>'
+'	  &ensp;&ensp;int y;<br>'
	+'&ensp;public:<br>'
+'int GetX();<br>'
+'int GetY();<br>'
+'void SetX(int _x);<br>'
+'void SetY(int _y);<a>}</a>;<br>'
+'Union Bits<a>{</a><br>'
  +'&ensp; Bits(unsigned int n);<br>'
   +'&ensp;&ensp;void ShowBits():<br>'
   +'&ensp;&ensp;unsigned int num;<br>'
+'unsigned char  c[sizeof(unsigned int)];<a>}</a>;<br>'   
+'</li></ul>'
+'<i>Спецификатор доступа действует, пока не встретит следующего в этом-же классе</i><br>'
+'<table border="1"><caption>Спецификаторы доступа к классу</caption>'
+'<tr><td style="color:#a05" width="70px">Спецификатор</td><td style="color:#808">Описание</td></tr>'
+'<tr><td>private:</td><td>Данные-члены и функции-члены доступны только '
+'для функций членов этого класса</td></tr>'
+'<tr><td>Protected:</td><td>Данные-члены и функции-члены доступны для функций-'
+'членов данного класса и классов, производных от него</td></tr>'
+'<tr><td>public:</td><td>Данные-члены и функции-члены класса доступны '
+'для функций-членов этого класса и других функций программы, в которой '
+'имеется представитель класса.</td></tr></table>'
+'<i>В с++ класс, структура и объединение это типы классов</i><br>'
+'<table border="1"><caption>различие между этими понятиями</caption>'
+'<tr><td>Различие</td><td>Классы</td><td>Структуры</td><td>Объединения</td></tr>'
+'<tr><td>Ключевое слово</td><td>class</td><td>struct</td><td>union</td></tr>'
+'<tr><td>Доступ по умолчанию</td><td>private</td><td>public</td><td>public</td></tr>'
+'<tr><td>Перекрытие данных:</td><td>Нет</td><td>Нет</td><td>Да</td></tr>'
+'</table><ol>'
	+'<li><i>Пример использования объединения в качестве класса</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'union Bits{<br>'
	+'Bits(unsigned int n);<br>'
	+'void ShowBits();<br>'
	+'unsigned int num;<br>'
	+'unsigned char c[sizeof(unsigned int)];<br>'
+'};<br>'
+'Bits::Bits(unsigned int n){<br>'
	+'num=n;}<br>'
+'void<br>'
+'Bits::ShowBits(){<br>'
	+'int i,j;<br>'
+'	for(j=sizeof(unsigned int)-1;j>=0;j--){<br>'
		+'cout<<"Двоичное представление байта "<<j<<":";<br>'
	+'	for(i=128;i;i>>=1){<br>'
+'		if(i&c[j]) cout<<"1";<br>'
		+'else       cout<<"0";}<br>'
	+'cout<<"\n";}}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
  +'  setlocale(LC_ALL, "Rus");<br>'
+'    Bits ob(2000);<br>'
	+'ob.ShowBits(); <br>'
+'    return 0;<br>'
+'} <i>/*Двоичное представление байта 3:00000000<br>'
+'Двоичное представление байта 2:00000000<br>'
+'Двоичное представление байта 1:00000111<br>'
+'Двоичное представление байта 0:11010000*/</i><br>'
+'</li>'
	+'<h4>Конструкторы и деструкторы</h4> <br>'
+'<img src="https://i.postimg.cc/BQMFSgqy/kid.png"><br><b style="margin-left:30%">Это они</b></img><br>'
+'<a>Список инициализации элементов</a><br><li>'
+'<i>Конструктор класса вызывается каждый раз, когда создаётся его объект</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class AnyClass{<br>'
+'	int var;<br>'
   +'public:<br>'
    +'AnyClass(); <i>//конструктор</i><br>'
	+'void Show(); 	};<br>'
+'AnyClass::AnyClass(){<br>'
	+'cout<<"В конструкторе\n";<br>'
	+'var=4;}<br>'
+'void<br>'
+'AnyClass::Show(){<br>'
	+'cout<<var;}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'AnyClass ob;<br>'
  +'ob.Show();<br>'
  +'  return 0;<br>'
+'} <i>//в конструкторе 4</i><br></li><li>'
+'<a>Пример класса содержащий деструктор</a><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class AnyClass{<br>'
	+'int var;<br>'
   +'public:<br>'
    +'AnyClass(); <i>//конструктор</i><br>'
    +'~AnyClass(); <i>//деструктор</i><br>'
	+'void Show(); 	};<br>'
+'AnyClass::AnyClass(){<br>'
	+'cout<<"В конструкторе мы\n";<br>'
	+'var=4;}<br>'
+'AnyClass::~AnyClass(){<br>'
	+'cout<<"В деструкторе мы\n";}<br>'
+'void<br>'
+'AnyClass::Show(){<br>'
	+'cout<<var<<"\n";}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'AnyClass ob;<br>'
  +'ob.Show();<br>'
  +'  return 0;<br>'
+'} <i>//В конструкторе мы<br>'
+'//  4<br>'
+'//  В деструкторе мы (после идёт пустая строка)</i><br></li><li>'
+'<a>Модифицируем предыдущий пример(инициализируем переменные)</a><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class AnyClass{<br>'
	+'int a,b;<br>'
   +'public:<br>'
    +'AnyClass(int x,int y); <i>//конструктор + парметры </i><br>'
    +'~AnyClass(); <i>//деструктор</i><br>'
	+'void Show(); 	};<br>'
+'AnyClass::AnyClass(int x,int y){<br>'
	+'cout<<"В конструкторе мы\n";<br>'
	+'a=x;<br>'
	+'b=y;}<br>'
+'AnyClass::~AnyClass(){<br>'
	+'cout<<"В деструкторе мы\n";}<br>'
+'void<br>'
+'AnyClass::Show(){<br>'
	+'cout<<a<<" "<<b<<"\n";}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'AnyClass ob(5,9);<br>'
  +'ob.Show();<br>'
  +'  return 0;<br>'
+'} <i>//В конструкторе мы<br>'
+'// 5 9<br>'
+'// В деструкторе мы</i><br>'
+'</li></ol>'
	+'<a>Модифицируем предыдущий пример(инициализируем переменные)</a><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class AnyClass{<br>'
	+'int a,b;<br>'
   +'public:<br>'
    +'AnyClass(int x,int y); <i>//конструктор + парметры </i><br>'
    +'~AnyClass(); <i>//деструктор</i><br>'
	+'void Show(); 	};<br>'
+'AnyClass::AnyClass(int x,int y){<br>'
	+'cout<<"В конструкторе мы\n";<br>'
	+'a=x;<br>'
	+'b=y;}<br>'
+'AnyClass::~AnyClass(){<br>'
	+'cout<<"В деструкторе мы\n";}<br>'
+'void<br>'
+'AnyClass::Show(){<br>'
	+'cout<<a<<" "<<b<<"\n";}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'AnyClass ob(5,9);<br>'
  +'ob.Show();<br>'
  +'  return 0;<br>'
+'} <i>//В конструкторе мы<br>'
+'// 5 9<br>'
+'// В деструкторе мы</i><br>'
+'</li></ol>'
+'<li><a>По факту является сокращённой формой выражения:</a><br>'
+'AnyClass ob=AnyClass(5,9); - <i>все дела, Петруха!</i></li>'
+'<ul><i>Правила для всех конструкторов</i><br>'
+'<li type="disc">для конструктора не указывается тип возвращаемого значения;</li>'
+'<li type="disc">конструктор не может возвращать значение;</li>'
+'<li type="disc">констурктор не наследуется;</li>'
+'<li type="disc">конструктор не может быть объявлен с модификатором<br>'
+'const,valatile,static или virtual.</li>'
+'</ul><ul><i>И для деструктора:</i><br>'
+'<li type="disc">Деструктор не может иметь параметоров;</li>'
+'<li type="disc">деструктор не может возращать значение;</li>'
+'<li type="disc">деструктор не наследуется;</li>'
+'<li type="disc">класс не может иметь более одного деструтора;</li>'
+'<li type="disc">деструктор не может быть объявлен с модификатором <br>'
+'const,volatile,static или virtual.</li>'
+'</ul>'

+'</td></table>'




let kon;
kon='<table>'
+'<td id="lev"><h5>Конструкторы по умолчанию и конструкторы копирования</h5><br>'
+'<li><a>Указатель this</a><br>'
+'<i>Так как this передаётся по умолчанию, то:</i><br>'
+'ObjName.FuncName(par1,par2); <i>компилирует так:</i><br>'
+'ObjName.FuncName(&ObjName,par1,par2);<br>'
+'<a>использование указателя this</a><br>'
+'#include<iostream><br>'
+'#include<string.h><br>'
+'using namespace std;<br>'
+'class T{<br>'
	+'public:<br>'
		+'T(char*);<br>'
		+'void Greeting();<br>'
	+'	char item[20];};<br>'
+'T::T(char* name){<br>'
	+'strcpy(item,name);<br>'
	+'Greeting();         <i>//eqvi</i><br>'
	+'this->Greeting();   <i>//val</i><br>'
+'(*this).Greeting();} <i>//entni</i><br>'
+'void<br>'
+'T::Greeting(){<br>'
	+'<i>//eqvivalent oba</i><br>'
	+'cout<<"Hello, "<<item<<"\n";<br>'
	+'cout<<"Hello, "<<this->item<<"\n";}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
    +'T ob("diareja.");<br>'
  +'  return 0;<br>'
+'} <i>//Hello, diareja. (6 раз)</i><br></li><li>'
+'<a>Встраиваемые(inline-) функции</a><br>'
+'<ul>inline - функция не работает если:'
+'<li type="square">содержит оператор цикла(for,while,do-while);</li>'
+'<li type="square">содержит оператор switch или goto;</li>'
+'<li type="square">содержит статическую переменную(static);</li>'
+'<li type="square">если функция является рекрсивной;</li>'
+'<li type="square">имеет возвращаемый тип, отличный от void, и не содержит '
+'оператора return;</li>'
+'<li type="square">содержит встроенный код ассемблера</li>'
+'</ul>'
+'<a>Пример:</a><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'inline int even(int x){<br>'
	+'return !(x%2);}<br>'
+'int main(){<br>'
  +'  system("color 2f");<br>'
+'    setlocale(LC_ALL, "Rus");<br>'
    	 +'int n;<br>'
    	 +'cin>>n;<br>'
    	+' if(even(n)) cout<<n<<" chet\n";<br>'
    +'	 else cout<<n<<" nechet\n";<br>'
  +'  return 0;<br>'
+'} <i>//5 nechet<br>'
+'  //4 chet</i><br>'
+'</li>'
	+'<li><a>Статические члены класса</a><br>'
+'<ul><i>Придерживаемся следующих рекомендаций:</i><br>'
+'<li type="disc">Применяйте статические данные-члены для совьсестного '
+'использования данных несколькими объектами класса;</li>'
+'<li type="disc">Ограничьте доступ к статическим данным-членам, объявив '
+'их в разделе protected или private.</li></ul>'
+'<i>пример конечно:</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class T{<br>'
	+'public:<br>'
		+'T(){ObCount++;}<br>'
		+'~T(){ObCount--;}<br>'
		+'static int ObCount;<br>'
		+'//...<br>'
		+'private:<br>'
	+'		int x;};<br>'
+'int T::ObCount=0;<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
    	 +'T* pOb=new T[5];<br>'
    	+' cout<<" Имеется "&lt;&lt;T::ObCount&lt;&lt;" объектов типа T\n";<br>'
    +'	 delete[] pOb;<br>'
  +'  return 0;<br>'
+'} <i>// Имеется 5 объектов типа T</i><br>'
+'</li><li><a>Константные объекты и константные функции-члены класса. '
+'Ключевое слово mutable</a><br>'
+'<i>Объявление константной функции-члена класса:</i><br>'
+'class Coord{<br>'
	+'int x,y;<br>'
   +'public:<br>'
  +'  Coord(int _x, int _y);<br>'
+'void SetVal(int _x,int _y);	<br>'
+'<i>//и константная функция-член</i><br>'
+'void GetVal(int _x,int _y) const;<br>};<br>'
+'<i>константный объект:</i><br>'
+'const Coord ob(3,5);<br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class Coord{<br>'
	+'int x,y;<br>'
   +'public:<br>'
    +'Coord(int _x,int _y);<br>'
	+'void SetVal(int _x,int _y);<br>'
	+'void GetVal(int &_x,int &_y)const;	};<br>'
+'Coord::Coord(int _x, int _y){<br>'
	+'x=_x;<br>'
	+'y=_y;}<br>'
+'void Coord::SetVal(int _x,int _y){<br>'
	+'x=_x; y=_y;}<br>'
+'<i>//константная функция-член</i><br>'
+'void Coord::GetVal(int &_x,int &_y)const{<br>'
	+'_x=x;_y=y;}<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
    +'Coord pt1(3,8);<br>'
    +'const Coord pt(6,9);<i> //константный объект</i><br>'
    +'int x,y;<br>'
    +'pt1.GetVal(x,y);<br>' 
    +'pt2.SetVal(x,y);<i>//ошибка. Это не константа</i><br>'
  +'  pt2.GetVal(x,y); <i>//то-же самое</i><br>'
+'    return 0;} <i>//или ошибки, или ничего не возвращает</i><br>' 
+'<i>Чтобы обойти эти ограничения было придумана приблуда <a>mutable</a></i><br>'
+'Синтаксис: mutable<тип_данных><имя_переменной_члена>;<br> <i>Пример разумеется:</i><br>'
+'</li><li>'
+'<a>Использование указателей на функции-члены класса</a><br>'
+'<i>Синтаксис:</i><br>'
+'<возвра_тип><i>//!</i><br>'
+'&ensp;(<имя_класса>::<имя_указателя>)(<параметры>);<br>Показываю:<br>'
+'void(T::*funcPtr)(int x,int y);<br>'
+'<i>при использовании такой указатель должен быть разыменован</i><br>'
+'this->*funcPtr(x,y); или *this.* funcPtr(x,y);<br>'
+'<i>Использование указателей на функию-член</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class T{<br>'
	+'int i;<br>'
   +'public:<br>'
    +'void foo(){<br>'
  +'  	cout<<"Test::foo called"<<endl;}	};<br>'
+'int main(){<br>'
	+'typedef void(T::* pToFunc)(); <i>//тип указателя</i><br>'
	+'pToFunc pt=&T::foo; <i>//создание и инициализация</i><br>'
	+'T test; <i>//объект класса</i><br>'
	+'(test.*pt)(); <i>//функция по адресу</i><br>'
	+'T *test2=new T; <i>//по указателю</i><br>'
	+'(test2->*pt)();<br>'
	+'delete test2;<br>'
+'}<i>//Test::foo called<br>'
+'//Test::foo called (чё, понимай, как знаешь)</i><br>'
+'<ul><i>CCP вредная и поэтому накладывает ряд ограничений на этот способ</i><br>'
+'<li type="square">указатель на функцию-член класса не может ссылаться на статитеческую '
+'функцию член-класса(не передаётся указатель this)</li>'
+'<li type="square">указатель на функцию-член класса не может быть преобразован в '
+'указатель на обычнуюб функцию, не являющегося членом какого-нибудь класса(причина выше)</li>'
+'</ul></li><li><a>Массивы объектов класса</a><br>'
+'Anyclass obArr[10]; <i>10 элементов класса AnyClass</i><br>'
+'<i>Если что-то создаём, то обязательно указываем это(что, да как). Компилятор - тормоз и '
+'не понимает</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class AnyClass{<br>'
	+'int a;<br>'
  +' public:<br>'
+'    AnyClass(int n){a=n;}<br>'
	+'int GetA(){return a;}	};<br>'
 +'main(){<br>'
 +'	<i>//объявление и инициализация</i><br>'
+' 	AnyClass obArr[5]={13,17,21,23,27};<br>'
 	+'int i;<br>'
 +'	for(i=0;i<4;i++){<br>'
+' 		<i>//обращаемся к элементам массива</i><br>'
 		+'cout<<obArr[i].GetA()<<" ";}<br>'
 	+'cout<<"\n";<br>'
 +'	return 0;<br>'
+'} <i>//13 17 21 23(весь не выдал)</i><br>'
+'<i>Всё вышеназванное это форма следующей конструкции:</i><br>'
+'AnyClass obArr[5]={AnyClass(13),<br>'
+'&ensp;&ensp;AnyClass(17),<br>'
+'&ensp;&ensp;AnyClass(21),<br>'
+'&ensp;&ensp;AnyClass(23),<br>'
+'&ensp;&ensp;anyClass(27)};<br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class Coord{<br>'
	+'int x,y;<br>'
  +' public:<br>'
+'    Coord(int _x,int _y){x= _x;y= _y;}<br>'
    +'int GetX(){return x;}<br>'
  +'  int GetY(){return y;}	};<br>'
+'main(){<br>'
+'   Coord obArr[4]=(<br>' 
         +'         Coord(3,4),Coord(5,6),<br>'
       +'           Coord(7,8),Coord(9,10),<br>'
     +'             Coord(11,12),Coord(13,14),<br>'
   +'               Coord(15,16), Coord(17,18));<br>'
 +'                int i;<br>'
                 +'Coord* ptr;<br>'
				 +'ptr=obArr; <i>//инициализация указателя адресом</i><br>' 
				 +'for(i=0;i<4;i++){<br>'
				+' 	cout&lt;&lt;ptr->GetX()&lt;&lt;" ";<br>'
			+'	 	cout&lt;&lt;ptr->GetY()&lt;&lt;"\n";<br>'
		+'		 	ptr++;} <i>//далее по рангу</i><br>'				         
	+'			 cout<<"\n";     <br>'
 +'	return 0;<br>'
+'} 17 18 (4 раза)<br>'
+'<i>//и, вот они, два параметра:</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class Coord{<br>'
	+'int x,y;<br>'
  +' public:<br>'
+'    Coord(int _x,int _y){x= _x;y= _y;}<br>'
    +'int GetX(){return x;}<br>'
  +'  int GetY(){return y;}	};<br>'
+'main(){<br>'
+'   Coord coordArr[4][2]={<br>' 
   +'               Coord(3,4),Coord(5,6),<br>'
 +'                 Coord(7,8),Coord(9,10),<br>'
                 +' Coord(11,12),Coord(13,14),<br>'
                 +' Coord(15,16), Coord(17,18)};<br>'
                +' int i,j;               			<br>'
				+' for(i=0;i<4;i++)<br>'
				+' for(j=0;j<2;j++){<br>'
			+'	 	cout&lt;&lt;coordArr[i][j].GetX()&lt;&lt;" ";<br>'
		+'		 	cout&lt;&lt;coordArr[i][j].GetY()&lt;&lt;" ";}<br>'         
	+'			 cout&lt;&lt;"\n";     <br>'
 +'	return 0;<br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class Coord{<br>'
	+'int x,y;<br>'
  +' public:<br>'
+'    Coord(int _x,int _y){x= _x;y= _y;}<br>'
    +'int GetX(){return x;}<br>'
  +'  int GetY(){return y;}	};<br>'
+'main(){<br>'
+'   Coord obArr[4]=(<br>' 
                  +'Coord(3,4),Coord(5,6),<br>'
                  +'Coord(7,8),Coord(9,10),<br>'
                  +'Coord(11,12),Coord(13,14),<br>'
                  +'Coord(15,16), Coord(17,18));<br>'
                 +'int i;<br>'
                 +'Coord* ptr;<br>'
				 +'ptr=obArr; <i>//инициализация указателя адресом</i><br>' 
				 +'for(i=0;i<4;i++){<br>'
				+' 	cout&lt;&lt;ptr->GetX()&lt;&lt;" ";<br>'
			+'	 	cout&lt;&lt;ptr->GetY()&lt;&lt;"\n";<br>'
		+'		 	ptr++;} <i>//далее по рангу</i><br>'				         
	+'			 cout&lt;&lt;"\n";     <br>'
 +'	return 0;<br>'
+'} 17 18 (4 раза)<br>'
+'<i>//и, вот они, два параметра:</i><br>'
+'#include<iostream><br>'
+'using namespace std;<br>'
+'class Coord{<br>'
	+'int x,y;<br>'
  +' public:<br>'
+'    Coord(int _x,int _y){x= _x;y= _y;}<br>'
    +'int GetX(){return x;}<br>'
  +'  int GetY(){return y;}	};<br>'
+'main(){<br>'
+'   Coord coordArr[4][2]={<br>' 
          +'        Coord(3,4),Coord(5,6),<br>'
        +'          Coord(7,8),Coord(9,10),<br>'
      +'            Coord(11,12),Coord(13,14),<br>'
    +'              Coord(15,16), Coord(17,18)};<br>'
  +'               int i,j;               			<br>'
+'				 for(i=0;i<4;i++)<br>'
				+' for(j=0;j<2;j++){<br>'
			+'	 	cout&lt;&lt;coordArr[i][j].GetX()&lt;&lt;" ";<br>'
		+'		 	cout&lt;&lt;coordArr[i][j].GetY()&lt;&lt;" ";}<br>'         
	+'			 cout&lt;&lt;"\n";     <br>'
 +'	return 0;<br>'
+'}  <i>//3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</i><br>'
+'</li>'
+'</td><td id="prav">'
+'</td></table>'

document.write(kon)+func+nachalo;

