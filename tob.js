let nachalo;
nachalo='<table border="1"><td id="lev">'
+'<li><i>реально правильное определение максроса</i><br>'
+'&ensp;#define SQUARE(x) ((x)*(x))-<i>Не забываем про скобки</i><br>'
+'&ensp;<a>Также надо внимательно ставить пробелы. Тут они тоже несут смысловую нагрузку</a><br>'
+'<i>Для продолжения макроса при переносе на другую строку ставится знак &#47;</i><br>'
+'#define MAKEWORD(a,b) ((WORD) (((BYTE)(a))&ensp;&#47;<br>'
+'|((WORD)((BYTE)(b)))&lt;&lt;8)))<br>'
+'<i>Далее приведём примеры вложенных макросов:</i><br>'
+'#define PI 3.14159<br>'
+'#define SQUARE(x) ((x)*(x))<br>'
+'#define CIRCLE_AREA(x) (PI*SQUARE(x)) - <i>Мы в шоке</i><br>'
+'<a>аннулирование макроса в любом месте программы производится директивой #undef</a></li><li>'
+'<table border="1"><caption>Предопределённые максросы ANSI</caption><br>'
+'<tr><td width="100">Макрос</td><td>Описание</td></tr>'
+'<tr><td>_DATE_</td><td>Строка представляющая в форме mmm.dd.yyyy дату '
+'создания данного файла</td></tr>'
+'<tr><td>_FILE_</td><td>Имя текущего обрабатываемого файла</td></tr>'
+'<tr><td>_LINE_</td><td>Номер текущей строки обрабатываемого файла</td></tr>'
+'<tr><td>_STDC_</td><td>Опеределён, если установлен режим совместимости с ANSI C</td></tr>'
+'<tr><td>_TIME_</td><td>время начала обработки текущего файла в формате hh:mm:ss</td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'<tr><td></td><td></td></tr>'
+'</table><i>И пример использования конечно:</i><br>'
+'#include<iostream><br>'
+'#include <stdio.h><br>'
+'char* Date = __DATE__;<br>'
+'char* Time = __TIME__;<br>'
+'int main(){<br>'
  +'  system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'FILE* file;<br>'
  +'//...<br>'
  +'file=fopen("Ex.cpp","r+t");<br>'
  +'if(file==NULL){<br>'
  	+'std::cout<<"Error fopen() "<<__FILE__<<" файл, "<<__LINE__<<" строка";<br>'
  	+'return 1;}<br>'
    +'return 0;<br>'
+'} <i>//адрес программы выдал</i><br></li><li>'
+'<b>Операциии в директивых препроцессора</b><br>'
+'<i>Есть две операции: 1)подстановка сроки(#), 2)конкатенация</i><br>'
+'<ul><h3>Функции ввода-вывода</h3><br>'
+'<li>считывание блока данных из потока в оперативную память</li>'
+'<li>запись блока данных из оперативной памяти в поток</li>'
+'<li>обновление блока данных в потоке</li>'
+'<li>считвание записи из потока</li>'
+'<li>занесение записи в поток</li>'
+'</ul></li><li>'
+'<i>Когда начинается выполнение программы, открываются следующие потоки:</i><br>'
+'stdin<i>-стандартное устройство ввода;</i><br>'
+'stdout<i>-стандартное устройство вывода</i><br>'
+'stderr<i>-стандартное утсройство сообщений об ошибках;</i><br>'
+'stdprn<i>-стандартное устройство печати;</i><br>'
+'stdaux<i>-стандартное вспомогательное устройство</i><br>'
+'<i>переназнаение ввода с клавиатуры на файл:</i><br>'
+'example &lt; sample.dat<br>'
+'<i>переназначение вывода с дисплея в файл:</i><br>'
+'example > output.dat<br>'
+'<i>Одновременное назначение ввода и вывода</i><br>'
+'example<sample.dat>output.dat<br>'
+'<i>соединение двух потоков:</i><br>'
+'example1 | example2<br></li><li>'
+'<a>Функции ввода и вывода символов</a><br>'
+'#define EOF (-1) <i>- Макрос</i><hr>'
+'#define EOF (-1)<br>'
+'#include <stdlib.h><br>'
+'using namespace std;<br>'
+'int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'char ch;<br>'
  +'cout<<"symbol: ";<br>'
  +'ch=getc(stdin);<br>'
  +'printf("Symbol: "%c"\n", ch);<br>'
  +'  return 0;<br>'
+'} <i>//f - "f"</i><br>'
+'</li><ul><a>Функции ввода и вывода строк</a><br>'
+'<li>gets() - char *gets(char *s) <i>cчитывание строки и помещение в переменную(до 5 символов)</i></li>'
+'<li>puts() - int puts(const char *s) <i>выводит тсроку и добавляет символ перевода</i><br>'
+'&ensp;#include<cstdio><br>'
+'int main(){<br>'
	+'&ensp;char* string="strochka";<br>'
	+'&ensp;puts(string);<br>'
+'return 0;<br>'
+'} <i>//strochka</i><br>'
+'</li>'
+'<li>Функция scanf() <i>int scanf(const char *format[, address, ...]);</i></li>'
+'</ul><hr><ul>Объекты строки форматирования<br>'
+'<li type="square">символы - заполнители <i>пробел (&#47;t) и перевод строки (&#47;n)</i></li>'
+'<li type="square">Символы отличные от символов-заполнителей <i> все ASCII кроме %</i></li>'
+'<li type="square">Спецификаторы формата <i>заведуют адресами переменных</i></li>'
+'</ul>'
	+'<table border="1"><caption>Знаки спецификатора формата и зачем нужны</caption>'
+'<tr><td style="color:#ff0">Компонент</td><td style="color:#fff">Обяза-<br>тельный<br>'
+'или нет</td><td style="color:#808">назначение</td></tr>'
+'<tr><td>[*]</td><td>Нет</td><td>Символ подавления присвоения переменной '
+'значения слудующего поля. Текуще поле ввода сканируется, но не сохраняется '
+'в переменной<br>Предполагается, что аргумент, соответствующий спецификатору '
+'формата, содержащему звёздочку, имеет тип, указанный символом типа преобразования '
+'(type_char), который идёт за звёздочкой</td></tr>'
+'<tr><td>[width]</td><td>Нет</td><td>Спецификатор ширины поля. Задаёт максимальное '
+'число считываемых символов. Функция может прочесть меньше символов, если '
+'в потоке ввода встретится символ-заполнитель или непреобразуемый символ</td></tr>'
+'<tr><td>[F|N]</td><td>Нет</td><td>Модификатор величины указателя. Преопределяет '
+'велину по умолчанию аргумента, задающего адрес:<br>N=near pointer<br>'
+'F=far pointer</td></tr>'
+'<tr><td>[h|l|L]</td><td>Нет</td><td>Модификатор типа аргумента. Переолпределяет '
+'тип по умолчанию аргумента, задающего адрес:<br>h=short int<br>'
+'l=long int, если type_char задаёт преобразование в целое l=double; если type_char '
+'преобразование в тип с плавающей точкой. L=long double(верно только для '
+'преобразования в тип с плавающей точкой)</td></tr>'
+'<tr><td>type_char</td><td>Да</td><td>Символ типа(преобразования)(или спецификатор '
+'преобразования)</td></tr>'
+'</table><table border="1"><caption>Символы типа преобразования</caption>'
+'<tr><td>Тип данных</td><td>Ожидаемый вывод</td><td>Тип аргумента</td></tr>'
+'<tr><td colspan="3"><center style="color:#700">Числовой</center/td></tr>'
+'<tr><td>D</td><td>Десятичное целое</td><td>Указатель на целое<br>(int *arg)</td></tr>'
+'<tr><td>D</td><td>Десятичное целое</td><td>Указатель на длинное целое(long *arg)</td></tr>'
+'<tr><td>E,E</td><td>Число с плавающей точкой</td><td>Указатель на float(float *arg)</td></tr>'
+'<tr><td>f</td><td>Число с плавающей точкой</td><td>Указатель на float(float *arg)</td></tr>'
+'<tr><td>G,G</td><td>Число с плавающей точкой</td><td>Указатель на float(float *arg)</td></tr>'
+'<tr><td>o</td><td>Восьмеричное целое</td><td>Указатель на int(int *arg)</td></tr>'
+'<tr><td>O</td><td>Восьмеричное целое</td><td>Указатель на long (long *arg)</td></tr>'
+'<tr><td>i</td><td>Десятичное,восьмеричное или шестнадцатеричное целое</td>'
+'<td>Указатель на int(int *arg)</td></tr>'
+'<tr><td>I</td><td>Десятичное, восмеричное или шестнадцатеричное целое</td>'
+'<td>Указатель на long(long *arg)</td></tr>'
+'<tr><td>u</td><td>Беззнаковое десятичное целое</td><td>Указатель на unsigned int'
+'(unsigned int *arg)</td></tr>'
+'<tr><td>U</td><td>Беззнаковое десятичное целое</td><td>Указатель на unsigned long'
+'(unsigned long *arg)</td></tr>'
+'<tr><td>x</td><td>Шестнащдццатеричное целое</td><td>Указатель на int(int *arg)</td></tr>'
+'<tr><td>X</td><td>Шестнадцатеричное целое</td><td>Указатель на int(int *arg)</td></tr>'
+'<tr><td colspan="3"></td></tr>'
+'<tr><td colspan="3"><center style="color:#505">Символы</center/td></tr>'
+'<tr><td>s</td><td>Символьная строка</td><td>Указатель на символьный массив (char arg[])</td></tr>'
+'<tr><td>c</td><td>Символ</td><td>Указатель на символ(char *arg), если задана '
+'ширина поля для символов С-типа(например %5С). Указатель на массив из '
+'N символов<br>(char arg[N])</td></tr>'
+'<tr><td>%</td><td>%символ</td><td>Никакое преобразование не выполнятеся; '
+'знак % сохраняется</td></tr>'
+'<tr><td colspan="3"><center style="color:#44a">Указатели</center></td></tr>'
+'<tr><td>n</td><td>Указатель на int(int *arg)</td><td>Число успешно прочитанных '
+'символов, вплоть до %n сохраняется в этом ште</td></tr>'
+'<tr><td>p</td><td>Шестнадцатеричная форма<br>YYYY:ZZZZ или ZZZZ</td><td>Указатель '
+'на объект (far* или near*).<br>По умолчанию %p преобразовывает в указатель, '
+'величина которого принята в данной модели памяти</td></tr>'
+'</table>'
+'<li><a>Спецификаторы формата</a><br>'
+'<a>%[abcd]</a> - поиск во входном потоке любого из символов a,b,c,d<br>'
+'<a>%[^abcd]</a> - поиск всех символов, исключая a,b,c,d<br>'
+'<i>int main(){<br>'
    +'system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
  +'char symbol;<br>'
  +'cout<<"symbol: ";<br>'
  +'symbol!="a"||"b"||"c"||"d";<br>'
  +'for(int i=0;i<5;i++){<br>'
	+'  cin>>symbol; <a>//a,b,c,d,f</a><br>'
+'}<br>'
+'cout&lt;&lt;symbol;<br>'
  +'  return 0;<br>'
+'}  <a>// f</a></i><br>'
+'<i>Также: </i><br>%[0-9] - Поиск во входном поле любой десятичной цифры<br>'
+'%[0-9A-Za-z] - Поиск во входном потоке десятичных цифр и букв<br>'
  +'</td><td id="lpcool"></td>'
+'<td id="prav">'
	+'<li><a>sscanf()</a><br>'
+'#include<iostream><br>'
+'#include <stdio.h><br>'
+'using namespace std;<br>'
+'int main(){<br>'
  +'  system("color 2f");<br>'
    +'setlocale(LC_ALL, "Rus");<br>'
    +'char szBuf1[]="***This function can parcse string***";<br>'
+'    char szBuf2[]="Integer i=12345,f1=123.456";<br>'
  +'  char s[5][11]; char str1[11],str2[11];<br>'
    +'char c1,c2,c3;int i;float fl;<br>'
+'    sscanf(szBuf1,"%s %s %s %s %s ",s[0],s[1],s[2],s[3],s[4]);<br>'
  +'  sscanf(szBuf2,"%s %c %c %d %s %c %f",str1,&c1,&c2,&i,str2,&c3,&fl);<br>'
    +'printf("sscanf() parse this string: \n"<br>'
	  +'      "%s %s %s %s %s\n ",<br>'
		+'	   s[0],s[1],s[2],s[3],s[4]);<br>'
+'	printf("szBuf2 contains:\n %s %c %c %d %s %c %8.3f ",<br>'
	+'         str1,c1,c2,i,str2,c3,fl);<br>'		   
+'    return 0;<br>'
+'} <i>//возвратила только числа<br>'
+'// Integer i = 12345 ,f1=123.456 ¦    0,000</i><br></li><li>'
+'<ul><a>Строка форматирования в функции printf()</a><br>'
+'Содержит два типа:<br><li type="square">Простые символы, которые копируются '
+'в выходной поток;</li>'
+'<li type="square">Спецификаторы формата, которые применяются к аргументам, '
+'выбираемым из списка аругментов</li></ul>'
+'<a>% [flags] [width] [.prec] [F|N|h|l|L] type_char</a><br>'
+'<table border="1"><caption style="font-size:16px">Компоненты спецификатора формата '
+'и их назначение</caption>'
+'<tr><td width="100px"><i>Компонент</i></td><td width="80px"><i style="margin:0">Обязательный или нет</i></td><td width="200px"><i>Назначение</i></td></tr>'
+'<tr><td>[flags]</td><td>Нет</td><td>Флаговые символы. Управляют выравниванием, '
+'знаком числа, десятичной точкой, конечными нулями, префиксами для восьмеричных '
+'и шестнадцатеричных чисел.</td></tr>'
+'<tr><td>[width]</td><td>нет</td><td>Спецификатор ширины(поля). Указывает '
+'минимальное число выводимых сиволов(дополняются, если это необходимо, '
+'пробелами или нулями)</td></tr>'
+'<tr><td>[prec]</td><td>нет</td><td>Спецификатор точности. Указывает макимальное '
+'число выводимых символов; для целых чисел - минимальное число выводимых цифр.</td></tr>'
+'<tr><td>[F|N|h|l|L]</td><td>нет</td><td>Модификатор размера. Переопределяет '
+'размер входного аргумента по умолчанию.</td></tr>'
+'<tr><td>Type_char</td><td>да</td><td>Символ типа преобразователя</td></tr>'
+'</table><table border="1" bordercolor="#888"><caption>Флаговые символы(флажки) и их назначение</caption>'
+'<tr><td>Флажок</td><td>Назначение</td></tr>'
+'<tr><td>"-"</td><td>Выравнивает результат преобразования влево, дополняя его '
+'справа пробелами. По умолчанию(т.е. когда этот флажок ещё не задан) результат '
+'преобразорвания выравнивается вправо и дпоолняется слева нулями или пробелами.</td></tr>'
+'<tr><td>"+"</td><td>Если результат преобразования имеет знак, этот знак всегда выводится. '
+'Это означает, что для положительных чисел выводится знак плюс (+).</td></tr>'
+'<tr><td style="text-align:center">пробел<br>(" ")</td><td>Если значение отрицательно, вывод начинается с пробела '
+'вместо знака плюс. Отрицательные числа по-прежнему выводятся со знаком минус.</td></tr>'
+'<tr><td>"#"</td><td>Задаёт, что аргумент преобразуется с использованием '
+'альтернативной формы</td></tr>'
+'</table>'
+'</li></td></table>'
document.write(nachalo);
